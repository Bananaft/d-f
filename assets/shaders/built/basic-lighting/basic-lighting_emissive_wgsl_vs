diagnostic(off, derivative_uniformity);

struct vs_params {
  /* @offset(0) */
  u_projViewMatrix : mat4x4f,
  /* @offset(64) */
  u_modelMatrix : mat4x4f,
  /* @offset(128) */
  u_color : vec4f,
}

var<private> color : vec4f;

var<private> color0 : vec4f;

@group(0) @binding(0) var<uniform> x_16 : vs_params;

var<private> uv : vec2f;

var<private> texcoord0 : vec2f;

var<private> normal : vec3f;

var<private> normals : vec3f;

var<private> tangent : vec4f;

var<private> tangents : vec4f;

var<private> position_1 : vec4f;

var<private> pos : vec4f;

var<private> gl_Position : vec4f;

fn main_1() {
  let x_12 : vec4f = color0;
  let x_21 : vec4f = x_16.u_color;
  color = (x_12 * x_21);
  let x_28 : vec2f = texcoord0;
  uv = x_28;
  let x_35 : mat4x4f = x_16.u_modelMatrix;
  let x_38 : vec3f = normals;
  let x_45 : vec4f = normalize((x_35 * vec4f(x_38.x, x_38.y, x_38.z, 0.0f)));
  normal = vec3f(x_45.x, x_45.y, x_45.z);
  let x_49 : vec4f = tangents;
  tangent = x_49;
  let x_52 : mat4x4f = x_16.u_modelMatrix;
  let x_54 : vec4f = pos;
  position_1 = (x_52 * x_54);
  let x_64 : mat4x4f = x_16.u_projViewMatrix;
  let x_65 : vec4f = position_1;
  gl_Position = (x_64 * x_65);
  return;
}

struct main_out {
  @location(0)
  color_1 : vec4f,
  @location(1)
  uv_1 : vec2f,
  @location(2)
  normal_1 : vec3f,
  @location(3)
  tangent_1 : vec4f,
  @location(4)
  position_1_1 : vec4f,
  @builtin(position)
  gl_Position : vec4f,
}

@vertex
fn main(@location(1) color0_param : vec4f, @location(2) texcoord0_param : vec2f, @location(3) normals_param : vec3f, @location(4) tangents_param : vec4f, @location(0) pos_param : vec4f) -> main_out {
  color0 = color0_param;
  texcoord0 = texcoord0_param;
  normals = normals_param;
  tangents = tangents_param;
  pos = pos_param;
  main_1();
  return main_out(color, uv, normal, tangent, position_1, gl_Position);
}

